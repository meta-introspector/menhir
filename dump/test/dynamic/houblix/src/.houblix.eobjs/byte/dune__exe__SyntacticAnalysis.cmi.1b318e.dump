[
  signature_item (_none_[0,0+-1]..[0,0+-1]) ghost
    Psig_attribute "ocaml.ppx.context"
    [
      structure_item (_none_[0,0+-1]..[0,0+-1]) ghost
        Pstr_eval
        expression (_none_[0,0+-1]..[0,0+-1]) ghost
          Pexp_record
          [
            "tool_name" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_constant PConst_string("ppx_driver",(_none_[0,0+-1]..[0,0+-1]) ghost,None)
            "include_dirs" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "load_path" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "open_modules" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "for_package" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "None" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "debug" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "use_threads" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "use_vmthreads" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "recursive_types" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "principal" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "transparent_modules" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "unboxed_types" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "unsafe_string" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "cookies" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
          ]
          None
    ]
  signature_item (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58])
    Psig_attribute "ocaml.text"
    [
      structure_item (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58])
        Pstr_eval
        expression (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58])
          Pexp_constant PConst_string(" This module helps combining {!Lexer} and {!Parser}. ",(test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58]),None)
    ]
  signature_item (test/dynamic/houblix/src/syntacticAnalysis.mli[3,60+0]..[8,212+6])
    Psig_value
    value_description "process" (test/dynamic/houblix/src/syntacticAnalysis.mli[3,60+4]..[3,60+11]) (test/dynamic/houblix/src/syntacticAnalysis.mli[3,60+0]..[8,212+6])
      attribute "ocaml.doc"
        [
          structure_item (test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31])
            Pstr_eval
            expression (test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31])
              Pexp_constant PConst_string(" [process lexer_init lexer_fun parser_fun input] initializes a lexer,\n    and composes it with a parser in order to transform an input text into\n    an abstract syntax tree. ",(test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31]),None)
        ]
      core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+2]..[8,212+6])
        Ptyp_arrow
        Labelled "lexer_init"
        core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+14]..[4,74+27])
          Ptyp_arrow
          Nolabel
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+14]..[4,74+16])
            Ptyp_var a
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+20]..[4,74+27])
            Ptyp_var lexbuf
        core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+2]..[8,212+6])
          Ptyp_arrow
          Labelled "lexer_fun"
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+13]..[5,106+30])
            Ptyp_arrow
            Nolabel
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+13]..[5,106+20])
              Ptyp_var lexbuf
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+24]..[5,106+30])
              Ptyp_var token
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+2]..[8,212+6])
            Ptyp_arrow
            Labelled "parser_fun"
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+14]..[6,141+52])
              Ptyp_arrow
              Nolabel
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+15]..[6,141+32])
                Ptyp_arrow
                Nolabel
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+15]..[6,141+22])
                  Ptyp_var lexbuf
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+26]..[6,141+32])
                  Ptyp_var token
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+37]..[6,141+52])
                Ptyp_arrow
                Nolabel
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+37]..[6,141+44])
                  Ptyp_var lexbuf
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+48]..[6,141+52])
                  Ptyp_var ast
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[7,198+2]..[8,212+6])
              Ptyp_arrow
              Labelled "input"
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[7,198+8]..[7,198+10])
                Ptyp_var a
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+2]..[8,212+6])
                Ptyp_var ast
      []
]

[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    load_path = [];
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    transparent_modules = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = []
  }]
[@@@ocaml.text " This module helps combining {!Lexer} and {!Parser}. "]
val process :
  lexer_init:('a -> 'lexbuf) ->
    lexer_fun:('lexbuf -> 'token) ->
      parser_fun:(('lexbuf -> 'token) -> 'lexbuf -> 'ast) -> input:'a -> 'ast
[@@ocaml.doc
  " [process lexer_init lexer_fun parser_fun input] initializes a lexer,\n    and composes it with a parser in order to transform an input text into\n    an abstract syntax tree. "]
[
  signature_item (_none_[0,0+-1].._none_[0,0+-1]) ghost
    Tsig_attribute "ocaml.ppx.context"
    [
      structure_item (_none_[0,0+-1]..[0,0+-1]) ghost
        Pstr_eval
        expression (_none_[0,0+-1]..[0,0+-1]) ghost
          Pexp_record
          [
            "tool_name" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_constant PConst_string("ppx_driver",(_none_[0,0+-1]..[0,0+-1]) ghost,None)
            "include_dirs" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "load_path" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "open_modules" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "for_package" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "None" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "debug" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "use_threads" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "use_vmthreads" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "recursive_types" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "principal" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "transparent_modules" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "unboxed_types" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "unsafe_string" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "false" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
            "cookies" (_none_[0,0+-1]..[0,0+-1]) ghost
              expression (_none_[0,0+-1]..[0,0+-1]) ghost
                Pexp_construct "[]" (_none_[0,0+-1]..[0,0+-1]) ghost
                None
          ]
          None
    ]
  signature_item (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+58])
    Tsig_attribute "ocaml.text"
    [
      structure_item (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58])
        Pstr_eval
        expression (test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58])
          Pexp_constant PConst_string(" This module helps combining {!Lexer} and {!Parser}. ",(test/dynamic/houblix/src/syntacticAnalysis.mli[1,0+0]..[1,0+58]),None)
    ]
  signature_item (test/dynamic/houblix/src/syntacticAnalysis.mli[3,60+0]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
    Tsig_value
    value_description process/285 (test/dynamic/houblix/src/syntacticAnalysis.mli[3,60+0]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
      attribute "ocaml.doc"
        [
          structure_item (test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31])
            Pstr_eval
            expression (test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31])
              Pexp_constant PConst_string(" [process lexer_init lexer_fun parser_fun input] initializes a lexer,\n    and composes it with a parser in order to transform an input text into\n    an abstract syntax tree. ",(test/dynamic/houblix/src/syntacticAnalysis.mli[9,219+0]..[11,367+31]),None)
        ]
      core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+2]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
        Ttyp_arrow
        Labelled "lexer_init"
        core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+14]..test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+27])
          Ttyp_arrow
          Nolabel
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+14]..test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+16])
            Ttyp_var a
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+20]..test/dynamic/houblix/src/syntacticAnalysis.mli[4,74+27])
            Ttyp_var lexbuf
        core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+2]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
          Ttyp_arrow
          Labelled "lexer_fun"
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+13]..test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+30])
            Ttyp_arrow
            Nolabel
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+13]..test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+20])
              Ttyp_var lexbuf
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+24]..test/dynamic/houblix/src/syntacticAnalysis.mli[5,106+30])
              Ttyp_var token
          core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+2]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
            Ttyp_arrow
            Labelled "parser_fun"
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+14]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+52])
              Ttyp_arrow
              Nolabel
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+15]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+32])
                Ttyp_arrow
                Nolabel
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+15]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+22])
                  Ttyp_var lexbuf
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+26]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+32])
                  Ttyp_var token
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+37]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+52])
                Ttyp_arrow
                Nolabel
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+37]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+44])
                  Ttyp_var lexbuf
                core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+48]..test/dynamic/houblix/src/syntacticAnalysis.mli[6,141+52])
                  Ttyp_var ast
            core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[7,198+2]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
              Ttyp_arrow
              Labelled "input"
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[7,198+8]..test/dynamic/houblix/src/syntacticAnalysis.mli[7,198+10])
                Ttyp_var a
              core_type (test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+2]..test/dynamic/houblix/src/syntacticAnalysis.mli[8,212+6])
                Ttyp_var ast
      []
]

